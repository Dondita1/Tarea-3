}
// Aplicación de consola para gestionar cursos
// Requisitos: C++17, CMake. Funciona en Windows y Linux.

#include <algorithm>
#include <cctype>
#include <cstdint>
#include <cstdio>
#include <cstring>
#include <fstream>
#include <iomanip>
#include <iostream>
#include <limits>
#include <sstream>
#include <string>
#include <vector>
#include <cstddef>

#if defined(_WIN32)
#include <windows.h>
#endif

using namespace std;

static const char* BIN_FILENAME = "cursos.dat";
static const char* WEB_DIR = "web";
static const char* WEB_JSON = "web/cursos.json";

// Filtro de salida: elimina comas de toda la salida por consola
class NoCommaBuf : public std::streambuf {
    std::streambuf* dest;
public:
    explicit NoCommaBuf(std::streambuf* d) : dest(d) {}
protected:
    int overflow(int ch) override {
        if (ch == std::char_traits<char>::eof()) {
            return dest->sputc(ch);
        }
        if (ch == ',') {
            // omitir coma
            return ch;
        }
        return dest->sputc(static_cast<char>(ch));
    }
    std::streamsize xsputn(const char* s, std::streamsize n) override {
        std::streamsize written = 0;
        for (std::streamsize i = 0; i < n; ++i) {
            if (s[i] == ',') continue; // omitir coma
            if (dest->sputc(s[i]) == std::char_traits<char>::eof()) break;
            ++written;
        }
        return written;
    }
};

#pragma pack(push, 1)
struct CursoRecord {
    int32_t codigo;       // entero positivo y único
    char nombre[60];      // cadena UTF-8 truncada segura a 60 bytes
    int32_t horas;        // entero >= 0
    double costo;         // double >= 0
};
#pragma pack(pop)

static_assert(sizeof(CursoRecord) == 4 + 60 + 4 + 8, "Tamaño de registro inesperado");

// Utilidades de consola
void clear_stdin() {
    cin.clear();
    cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
}

void pausa() {
    cout << "\nPresioná Enter para continuar...";
    cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
}

void limpiar_pantalla() {
#if defined(_WIN32)
    system("cls");
#else
    system("clear");
#endif
}

// Validaciones y entrada robusta
int leer_entero(const string& prompt, int min_val = std::numeric_limits<int>::min()) {
    while (true) {
        cout << prompt;
        string line;
        if (!std::getline(cin, line)) {
            cin.clear();
            continue;
        }
        std::stringstream ss(line);
        long long v; // para chequear overflow
        if (ss >> v && !(ss >> line)) {
            if (v >= min_val && v <= std::numeric_limits<int>::max()) return static_cast<int>(v);
        }
        cout << "Entrada inválida. Intentá de nuevo." << endl;
    }
}

double leer_double(const string& prompt, double min_val = -std::numeric_limits<double>::infinity()) {
    while (true) {
        cout << prompt;
        string line;
        if (!std::getline(cin, line)) {
            cin.clear();
            continue;
        }
        std::stringstream ss(line);
        double v;
        if (ss >> v && !(ss >> line)) {
            if (v >= min_val) return v;
        }
        cout << "Entrada inválida. Intentá de nuevo." << endl;
    }
}

bool leer_confirmacion(const string& prompt) {
    while (true) {
        cout << prompt << " (s/n): ";
        string line;
        if (!std::getline(cin, line)) { cin.clear(); continue; }
        if (line.empty()) continue;
        char c = static_cast<char>(std::tolower(static_cast<unsigned char>(line[0])));
        if (c == 's') return true;
        if (c == 'n') return false;
        cout << "Respuesta inválida. Poné 's' o 'n'." << endl;
    }
}

string leer_linea(const string& prompt) {
    cout << prompt;
    string line;
    std::getline(cin, line);
    return line;
}

// UTF-8 helpers: truncamiento seguro a N bytes sin cortar multibyte
static bool is_utf8_start_byte(unsigned char b) {
